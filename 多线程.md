# 一、线程
## 1.线程的状态
```
1、新建(New)：新创建了一个线程对象，尚未启动。
2、运行（Runnable）：Runnable包括了操作系统线程状态中的Running和Ready，也就是说线程可能执行也可能正在等待CPU分配执行时间。
3.无限期等待（Waiting）：处于这种状态的线程不能被分配CPU执行时间，要等待其他线程显式唤醒。
4.限期等待（Timed Waiting）：处于这种状态的线程也不会被分配CPU执行时间，在一定时间之后他们由系统自动唤醒。
5.阻塞（Blocked）：线程被阻塞了。阻塞状态与等待状态的区别是：阻塞状态在等待着获取一个排它锁，这个事件将在另一个线程放弃这个锁的时候发生；而等待状态咋说在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。
6.结束（Terminated）：已终止线程的线程状态，线程已经结束执行。
```

 ## 2.线程状态转换

![1551522492873](C:\Users\d007l\AppData\Roaming\Typora\typora-user-images\1551522492873.png)

## 3.线程的实现

    1.继承Thread类；
    2.实现Runnable接口；
    3.实现callable接口。
## 4.线程的调度

​	线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种：协同式线程调度（Cooperative Threads-Scheduling）和抢占式线程调度（Preemptive Threads-Scheduling）。

- 协同式线程调度：线程的执行时间由自己控制，执行完工作后主动通知系统切换至另一线程。
- 抢占式线程调度：每个线程由系统分配执行时间。Java线程调度是这个。

# 二、多线程

## 1.并行与并发
    并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。
    并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。
        一、TPS：Transactions Per Second（每秒传输的事物处理个数），即服务器每秒处理的事务数。TPS包括一条消息入和一条消息出，加上一次用户数据库访问。（业务TPS = CAPS × 每个呼叫平均TPS）TPS是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。一般的，评价系统性能均以每秒钟完成的技术交易的数量来衡量。系统整体处理能力取决于处理能力最低模块的TPS值。
    
        二、QPS 每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。对应fetches/sec，即每秒的响应请求数，也即是最大吞吐能力。
## 2.线程安全
### 1> Java内存模型

#### A.硬件的效率与一致性

​	

```
由于计算机的存储设备与处理器的运算能力之间有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中没这样处理器就无需等待缓慢的内存读写了。
基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是引入了一个新的问题：缓存一致性（Cache 
Coherence）。在多处理器系统中，每个处理器都有自己的高速缓存，而他们又共享同一主存，多个处理器运算任务都涉及同一块主存，需要一种协议可以保障数据的一致性，这类协议有MSI、MESI、MOSI及Dragon
Protocol等。Java虚拟机内存模型中定义的内存访问操作与硬件的缓存访问操作是具有可比性的。
```



#### B.Java内存模型图

​	Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样底层细节。

　　Java内存模型中规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存（可以与前面将的处理器的高速缓存类比），线程的工作内存中保存了**该线程使用到的变量到主内存副本拷贝**，线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成，线程、主内存和工作内存的交互关系如下图所示

![1551688084188](C:\Users\d007l\AppData\Roaming\Typora\typora-user-images\1551688084188.png)

 #### C.内存交互的操作

​	Java内存模型共有8个操作，lock（锁定）、unlock（解锁）、read（读取）、load（载入）、use（使用）、assign（赋值）、store（存储）、write（写入）。

​	内存的变量状态有两种，一种是从线程到主内存（写操作），另一种是从主内存到线程（读操作）。

​	（指令操作有要求必须按一定顺序执行，具体的要求参见《深入理解Java虚拟机》）。

### 2> 线程安全的实现方法

#### A. 互斥同步

​	**同步**是指在多个线程并发访问共享数据时，保证共享数据在同一时刻只被一个（或者是一些，使用信号量的时候）线程使用。

​	**互斥**是实现同步的一种手段，临界区（Critical Section）、互斥量（Mutex）和信号量（Semaphore）都是互斥实现方式。

​	最基本的互斥同步手段就是**synchronized**关键字。

##### a.synchronized

​	synchronized关键字经过编译后，会在同步代码块的前后分别形成monitorenter和monitorexit这两个字节码指令，这两个字节码指令都需要一个reference类型的参数来指明要锁定和解锁的对象。

​	首先synchronized同步块对同一个线程来说是可重入的，不会出现自己把自己锁死的问题。其次，同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。

##### b.ReentranLock

​	我们还可以使用JUC包下的重入锁（ReentranLock）实现同步。

##### c.synchronized与ReentranLock比较

​	相比synchronized，ReentranLock增加了一些高级功能：

1. 等待可中断

2. 可实现公平锁（默认synchronized和ReentranLock都是非公平的，但ReentranLock可以通过带布尔值的构造函数要求使用公平锁）

3. 锁可以绑定多个条件

   ​	在jdk1.6及以后，synchronized优化了不少，所以优先考虑使用synchronized来进行同步。

   
#### B.非阻塞同步

   ​	互斥同步最主要的问题就是进行线程阻塞和唤醒时所带来的性能问题，因此这种同步也称为阻塞同步（Blocking Synchronization）。从处理问题的方式来说，互斥同步属于悲观的并发策略。

   ​	非阻塞同步（Non-Blocking Synchronization），基于冲突检测的乐观并发策略。就是先进行操作，如果没有其他线程争用共享数据，那就操作成功；如果出现争用，那就再采取补偿措施（最常见的补偿措施就是不断地重试，直到成功为止）。

   ​	非阻塞同步需要**操作**和**冲突检测**两个步骤具有**原子性**。（这个原子性靠硬件指令集来完成）

   ##### a.原子性处理器指令

- 测试并设置（Test-and-Set）

- 获取并增加（Fetch-and-Increment）

- 交换（Swap）

- 比较并交换（Compare-and-Swap）

- 加载链接/条件链接（Load-LInked/Store-Conditional，简称：LL/SC）

  前三条是20世纪就存在的，后面两条是现代处理器新增的。
##### b.CAS
​	CAS指令需要三个操作数，分别是内存位置（变量的内存地址，用V表示）、旧的预期值（用A表示）和新值（用B表示），CAS指令执行时，当且仅当V存的值符合预期值A时，处理器用新值B更新V存的值，否则不更新。但无论是否更新，都会返回V存的旧值。

​	有个漏洞就是“ABA”问题。目前Java给出的解决方案是提供了一个带有标记的原子引用类“AtomicStampedReference”，可以通过控制变量值得版本号来保证CAS的正确性。

#### C.无同步方案

  	**要保证线程安全，并不一定要同步，两者没有因果关系**。同步只是保证共享数据争用时的正确性的手段，如果一个方法本身不涉及共享数据，就不需要任何同步措施去保证正确性。有一些代码是天生线程安全的。

- **可重入代码（Reentrant Code）**：也叫纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。

  <!--所有的可重入的代码都是线程安全的，但并非所有的线程安全的代码都是可重入的-->

  ​	可重入代码的共同特征：不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。

  ​	**判断代码是否可重入**：如果一个方法，它的返回结果是可以预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，当然也是线程安全的。

  

- **线程本地存储（Thread Local Storage）**：如果一段代码中所需要的数据必须与其他线程共享，那就看看这些共享数据的代码是否保证在同一个线程中执行？如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无需同步也能保证线程之间不出现数据争用的情况。

  ​	最重要的一个应用实例就是经典Web交互模型中的“一个请求对应一个服务器线程”（Thread-per-Request）的处理方式。

  ​        Java中如果一个变量要被多个线程访问，可以使用**volatile**关键字申明为“易变的”。

### 3> 锁优化

#### A.自旋锁与自适应自旋

​	**自旋锁**：等待锁的线程执行一个忙循环“自旋”（不放弃处理器的执行时间）。

​	**自适应的自旋锁**意味着自旋的时间不再固定了，而是由**前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定** 。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                

#### B.锁清除

 	锁清除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。

#### C.锁粗化

​	如果虚拟机检测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。

#### D.轻量级锁

​	**Mark Word**：HotSpot虚拟机的对象头（Object Header）分为两部分信息，第一部分用于存储对象运行时数据，如哈希码（HashCode）、GC分代年龄（Generational GC Age）等，这部分数据的长度在32位和64位虚拟机中分别为32位和64位。**它是实现轻量级锁和偏向锁的关键**。

<!-- 另一部分用于存储指向方法区对象类型数据的指针，如果是数组的话，还存储了数组长度 -->

​	**轻量级锁的执行过程**

```
	在代码进入同步块的时候，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word拷贝（官方把这份拷贝加了一个Displaced前缀，即Displaced Mark Word），这时候线程堆栈与对象头的状态如图13-3所示。
	然后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针。如果更新成功，那么这个线程就拥有了该对象的锁，并且该对象的Mark Word的锁锁标志位（Mark Word的最后2bit）将转变为“00”，即表示此对象处于轻量级锁定状态，这时线程堆栈与对象头的状态如图13-4所示。
```

![1551699818057](C:\Users\d007l\AppData\Roaming\Typora\typora-user-images\1551699818057.png)

```
	如果这个更新失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果只说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程抢占了。如果有两个以上线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁，锁标志变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。
	上面描述的是轻量级锁的加锁过程，它的解锁过程也是通过CAS操作进行，如果对象的Mark Word仍然指向线程的锁记录，那就用CAS操作把当前对象的Mark Word和线程中复制的Displaced Mark Word替换回来，如果替换成功，说明同步完成。如果替换失败，说明有其他线程尝试过获取该锁，那就要在释放锁的同时，唤醒被挂起的线程。
```

​	轻量级锁提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。如果有竞争，轻量级锁使用CAS操作避免了使用互斥量的开销，但如果存在锁竞争，除了互斥量的开销外，还额外发生了CAS操作，因此在有竞争的情况下，轻量级锁会比传统的重量级锁更慢。

#### E.偏向锁

​	偏向锁的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。

​	偏向锁的意思就是这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他线程获取，则持有该偏向锁的线程永远不需要再进行同步。

​	假设当前虚拟机开启了偏向锁（启用参数 -XX:+UseBiasedLocking，这是jdk1.6的默认值），那么当锁对象第一次被线程获取时，对象头的标志位会设为“01”，即偏向模式。同时使用CAS操作把获取到这个锁的线程ID记录在Mark Word之中，如果CAS成功，持有偏向锁的线程以后每次进入这个锁的相关同步块时，虚拟机都不再进行任何同步操作（例如Locking、Unlocking、对Mark Word的Update等）。

​	当有另一个线程去尝试获取偏向锁时，偏向模式宣告结束。

![1551702085759](C:\Users\d007l\AppData\Roaming\Typora\typora-user-images\1551702085759.png)

<!--如果程序中大多数的锁总是被多个不同的线程访问，那偏向模式就是多余的。 -->

### 4> 乐观锁与悲观锁

​	悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如Java里面的同步原语synchronized关键字的实现也是悲观锁。

　　乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。



## 3.Executor框架	

### 1>线程池

​	是指管理一组同构工作线程的资源池。

#### A.线程池状态

![1551971334333](C:\Users\d007l\AppData\Roaming\Typora\typora-user-images\1551971334333.png)

```
1、RUNNING

(1) 状态说明：线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行处理。 
(02) 状态切换：线程池的初始化状态是RUNNING。换句话说，线程池被一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0！

private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));

2、 SHUTDOWN

(1) 状态说明：线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。 
(2) 状态切换：调用线程池的shutdown()接口时，线程池由RUNNING -> SHUTDOWN。

3、STOP

(1) 状态说明：线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。 
(2) 状态切换：调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -> STOP。

4、TIDYING

(1) 状态说明：当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理；可以通过重载terminated()函数来实现。 
(2) 状态切换：当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -> TIDYING。 
当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP -> TIDYING。

5、 TERMINATED

(1) 状态说明：线程池彻底终止，就变成TERMINATED状态。 
(2) 状态切换：线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -> TERMINATED。
```

#### B.线程池的处理流程

#### 线程池的处理流程主要分为3步

> - 提交任务后，线程池先判断线程数是否达到了核心线程数（corePoolSize）。如果未达到线程数，则创建核心线程处理任务；否则，就执行下一步；
> - 接着线程池判断任务队列是否满了。如果没满，则将任务添加到任务队列中；否则，执行下一步；
> - 接着因为任务队列满了，线程池就判断线程数是否达到了最大线程数。如果未达到，则创建非核心线程处理任务；否则，就执行饱和策略，默认会抛出RejectedExecutionException异常。

![img](https://upload-images.jianshu.io/upload_images/3096083-2286629fbc77d3b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/708)

#### 饱和策略：RejectedExecutionHandler

当任务队列和线程池都满了时所采取的应对策略，默认是AbordPolicy，表示无法处理新任务，并抛出RejectedExecutionException异常。此外还有3种策略：

> - CallerRunsPolicy：用调用者所在的线程处理任务。此策略提供简单的反馈机制，能够减缓新任务的提交速度。
> - DiscardPolicy：不能执行任务，并将任务删除。
> - DiscardOldestPolicy：丢弃队列最近的任务，并执行当前的任务。





## 4.死锁

### 1> 概念

​	死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。

### 2>产生条件

```
虽然进程在运行过程中，可能发生死锁，但死锁的发生也必须具备一定的条件，死锁的发生必须具备以下四个必要条件。 
	1）互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。
	2）请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。
	3）不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。
	4）环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。
```

### 3> 死锁排除方法

1. 撤消陷于死锁的全部进程；

2. 逐个撤消陷于死锁的进程，直到死锁不存在；

3. 从陷于死锁的进程中逐个强迫放弃所占用的资源，直至死锁消失。

4. 从另外一些进程那里强行剥夺足够数量的资源分配给死锁进程，以解除死锁状态

### 4> 避免死锁的方法

- **一次封锁法**：每个进程（事务）将所有要使用的数据全部加锁，否则，就不能继续执行；

- **顺序封锁法**：预先对数据对象规定一个封锁顺序，所有进程（事务）都按这个顺序加锁；

- **银行家算法**：保证进程处于安全进程序列。

### 5> 降低死锁的方法

- 按同一顺序访问对象；

- 避免事务中的用户交互；

- 保持事务简短并在一个批处理中；

- 使用低隔离级别。



# 三、问题汇总

## 1.线程相关

1.线程之间是怎么通信的？

​	synchronized同步、while轮询、wait/notify机制、管道通信

2.如何确定合适数量的线程？

![1551971574450](C:\Users\d007l\AppData\Roaming\Typora\typora-user-images\1551971574450.png)



## 2.线程池相关

1.构建线程池有哪些参数？

![1551971657711](C:\Users\d007l\AppData\Roaming\Typora\typora-user-images\1551971657711.png)

基本参数：

- int corePoolSize,

-  int maximumPoolSize,

-   long keepAliveTime,

- TimeUnit unit,

-  BlockingQueue<Runnable> workQueue

可增加参数：

- ThreadFactory threadFactory,
- RejectedExecutionHandler handler

2.提供的线程池有哪些？

![1551971803968](C:\Users\d007l\AppData\Roaming\Typora\typora-user-images\1551971803968.png)

![1551971811210](C:\Users\d007l\AppData\Roaming\Typora\typora-user-images\1551971811210.png)

3.线程池中 submit()和 execute()方法有什么区别？

1. submit()方法，可以提供Future < T > 类型的返回值。
   executor()方法，无返回值。

2. excute方法会抛出异常。
   sumbit方法不会抛出异常。除非你调用Future.get()。

3. excute入参Runnable
   submit入参可以为Callable
